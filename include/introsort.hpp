#pragma once

#include "vector"

namespace itis {

  /**
     * Вычисление середины области, заданной левой и правой индексами.
     *
     * @param start - индекс левой границы (включительно)
     * @param stop - индекс правой границы (включительно)
     * @return индекс середины области
     */
  inline constexpr int middle_of(int start, int stop) {
    return start + (stop - start) / 2;
  }

  /**
   * Двоичный поиск позиции вставки элемента в левый подмассив.
   *
   * @param arr - массив элементов
   * @param index - текущая позиция вставляемого элемента
   * @return позиция вставки элемента
   */
  int binary_search(const std::vector<int>& arr, int begin, int index);

  /**
     * Реализация алгоритма сортировки вставками.
     *
     * Сложность ~ от O(n) до O(n^2).
     *
     * @param arr - массив элементов
     */
  void InsertionSort(std::vector<int>& arr, int start, int stop);

  /**
   * Вычисление индекса медианы среди трех элементов массива.
   *
   * Медиана вычисляется среди трех элементов: началом, концом и серединой границы заданной области.
   * Середины области вычисляется функцией middle_of.
   *
   * @param arr - массив элементов
   * @param start - индекс начала границы области поиска медианы (включительно)
   * @param stop - индекс конца границы области поиска медианы (включительно)
   * @return индекс медианы среди трех элементов
   */
  int median_of_three(const std::vector<int>& arr, int start, int stop);

  /**
   * Разбиение массива в заданной области.
   *
   * Сложность по памяти ~ O(1).
   * Разбиение осуществляется строго в пределах заданной области.
   *
   * В реализации используется алгоритм Lomuto:
   *    1. Выбирается опорный элемент (pivot).
   *    2. Элементы меньше опорного передвигаются влево.
   *    3. Элементы больше или равные опорному передвигаются вправо.
   *
   * Перемещение элементов происходит непосредственно во входном массиве (не месте).
   *
   * В результате получается область массива, в котором слева от опорного элемента
   * все элементы меньше него, а справа - больше или равны.
   *
   * @param arr - массив элементов
   * @param start - индекс начала области разбиения (включительно)
   * @param stop - индекс конца области разбиения (включительно)
   * @param pivot - индекс опорного элемента в массиве (должен находится границах области разбиения)
   * @return индекс опорного элемента после совершения операции разбиения
   */
  int partition(std::vector<int>& arr, int start, int stop, int pivot);

  /**
     * Построение максимальной двоичной кучи.
     *
     * Сложность ~ O(n).
     *
     * Перемещение элементов входного массива таким образом,
     * чтобы массив удовлетворял свойствам максимальной двоичной кучи.
     *
     * @param arr - массив элементов
     */
  void BuildMaxHeap(std::vector<int>& arr, int start, int stop);

  /**
     * Итеративная реализация спуска элемента вниз по двоичной куче.
     *
     * @param arr - массив элементов
     * @param heap_size - размер двоичной кучи (от 0 до heap_size - 1)
     * @param index индекс спускаемого элемента
     */
  void Heapify(std::vector<int>& arr, int heap_size, int start, int index);

  // вспомогательные методы для вычисления индексов в двоичной куче
  int Parent(int index);
  int LeftChild(int index);
  int RightChild(int index);

  /**
     * Реализация итеративного алгоритма пирамидальной сортировки (Heap Sort).
     *
     * Сложность ~ O(n * log n).
     *
     * Элементы массива сортируются в порядке неубывания.
     * В реализации используется максимальная двоичная куча.
     *
     * @param arr - массив элементов
     */
  void HeapSort(std::vector<int>& arr, int start, int stop);

  /**
   * Вспомогательная метод для реализации интроспективной сортировки
   * @param arr - массив элементов
   * @param start - индекс начала сортируемого участка вектора
   * @param stop - индекс конца сортируемого участка вектора
   * @param depth_limit - лимит рекурсивных вызовов
   */
  void IntroSortUtil(std::vector<int>& arr, int start, int stop, int depth_limit);

  /**
   * Реализация интроспективной сортировки
   *
   * Алгоритм:
   *  1. сначала используется алгоритм быстрой сортировки
   *  2. когда глубина рекурсии превысит некоторый зараннее установленный уровень
   *  (в данной реализации 2 * log(n), где n - количество элементов), используется
   *  алгоритм пирамидальной сортировки.
   *  3. для последовательности, содержащей менее 16 элементов применяется
   *  алгоритм сортировки вставками.
   *
   *  Сложность по времени:
   *   Наихудший вариант: n*log(n)
   *   Средний случай: n*log(n)
   *   Лучший случай: n
   *
   *  Сложность по памяти:
   *   Общая: n
   *   Дополнительная: 1
   *
   *  Элементы массива сортируются в порядке неубывания.
   *
   * @param arr - массив элементов
   */
  void IntroSort(std::vector<int>& arr);
}
